<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Brain MNI Coordinate Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #333;
        font-family: Arial, sans-serif;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
      }
      .color-box {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin-right: 5px;
        border: 1px solid #666;
        vertical-align: middle;
      }
      .legend {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #ccc;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: Arial, sans-serif;
        font-size: 24px;
        color: #333;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 10px;
        z-index: 100;
      }
      #rotation-toggle,
      #split-brain-toggle,
      #axes-toggle {
        position: absolute;
        bottom: 20px;
        padding: 10px 15px;
        background-color: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        cursor: pointer;
        transition: background-color 0.3s;
        display: none; /* Initially hidden */
      }
      #rotation-toggle {
        left: 20px;
      }
      #split-brain-toggle {
        left: 150px;
      }
      #axes-toggle {
        left: 280px;
      }
      #rotation-toggle:hover,
      #split-brain-toggle:hover,
      #axes-toggle:hover {
        background-color: rgba(240, 240, 240, 0.9);
      }
      /* New styles for area controls */
      #area-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
        max-height: 80vh;
        overflow-y: auto;
        font-family: Arial, sans-serif;
      }
      #area-search {
        width: 100%;
        padding: 5px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      .area-item {
        margin: 5px 0;
        display: flex;
        align-items: center;
      }
      .area-checkbox {
        margin-right: 8px;
      }
      .area-color {
        width: 15px;
        height: 15px;
        display: inline-block;
        margin-right: 8px;
        border: 1px solid #666;
      }
      .no-areas-found {
        color: #666;
        font-style: italic;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h2>3D Brain MNI Coordinate Visualization</h2>
      <p>Loading coordinates: <span id="coordinate-count">0</span></p>
      <p>Brain dimensions: <span id="dimensions">Loading...</span></p>
      <p>
        Controls: Left-click + drag to rotate, scroll to zoom, right-click +
        drag to pan
      </p>
    </div>
    <div id="loading">Loading brain MNI coordinates...</div>
    <button id="rotation-toggle">Stop Rotation</button>
    <button id="split-brain-toggle">Split Brain</button>
    <button id="axes-toggle">Show Axes</button>

    <!-- New area controls panel -->
    <div id="area-controls">
      <h3>Brain Areas</h3>
      <input type="text" id="area-search" placeholder="Search areas..." />
      <div id="area-list">
        <!-- Area checkboxes will be added here dynamically -->
      </div>
    </div>

    <script>
      // Main Three.js variables
      let scene, camera, renderer, controls;
      let coordinateCount = 0;
      let brainGroup; // Store reference to the brain group for rotation
      let autoRotate = true; // Auto-rotation state
      let userInteracted = false; // Track if user has interacted with controls
      let isBrainSplit = false; // Track if brain is split
      let brainCoordinates = []; // Store brain coordinate data (MNI)
      let brainShape = []; // Store brain dimensions
      let brainInstancedMesh; // Reference to brain instanced mesh
      let brainEdges; // Reference to brain edges
      let axesHelper; // Reference to axes helper
      let showAxes = false; // Track if axes are shown

      // New variables for general area handling
      let availableAreas = []; // List of available areas
      let activeAreas = {}; // Map of active areas and their meshes
      let areaColors = {}; // Map of area colors

      // Color palette for different areas
      const colorPalette = [
        0x00aa00, // Green
        0x0055aa, // Blue
        0xaa0000, // Red
        0xaa00aa, // Purple
        0xaaaa00, // Yellow
        0x00aaaa, // Cyan
        0xff5500, // Orange
        0x5500ff, // Indigo
        0xff0055, // Pink
        0x55ff00, // Lime
      ];

      // Initialize the scene
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          75, // Increased FOV for a wider view
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.set(100, 0, 0); // Initial position before brain loads (from side)

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls for interaction
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = true; // Enable proper panning
        controls.minDistance = 5; // Allow closer zoom
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI; // Allow full vertical rotation
        controls.rotateSpeed = 0.7; // Adjust rotation speed

        // Set initial target to origin
        controls.target.set(0, 0, 0);
        controls.update();

        // Add event listeners to detect user interaction with controls
        controls.addEventListener("start", function () {
          if (autoRotate) {
            userInteracted = true;
            autoRotate = false;
            updateRotationButton();
          }
        });

        // Enhanced lighting setup for more balanced illumination
        // Increase ambient light for better overall visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        // Main directional light from top-right-front
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
        mainLight.position.set(1, 1, 1);
        scene.add(mainLight);

        // Back light to illuminate the posterior part of the brain
        const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
        backLight.position.set(-0.5, 0.5, -1);
        scene.add(backLight);

        // Bottom light for additional fill
        const bottomLight = new THREE.DirectionalLight(0xffffff, 0.3);
        bottomLight.position.set(0, -1, 0);
        scene.add(bottomLight);

        // Top light for additional illumination
        const topLight = new THREE.DirectionalLight(0xffffff, 0.3);
        topLight.position.set(0, 1, 0);
        scene.add(topLight);

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);

        // Set up rotation toggle button
        setupRotationToggle();

        // Set up split brain toggle button
        setupSplitBrainToggle();

        // Set up axes toggle button
        setupAxesToggle();

        // Set up area search functionality
        setupAreaSearch();

        // Load and visualize coordinates
        loadCoordinates();

        // Load available areas
        loadAvailableAreas();
      }

      // Set up rotation toggle button
      function setupRotationToggle() {
        const toggleButton = document.getElementById("rotation-toggle");
        toggleButton.addEventListener("click", function () {
          autoRotate = !autoRotate;
          if (autoRotate) {
            userInteracted = false; // Reset interaction flag when manually starting rotation
          }
          updateRotationButton();
        });
      }

      // Set up split brain toggle button
      function setupSplitBrainToggle() {
        const toggleButton = document.getElementById("split-brain-toggle");
        toggleButton.addEventListener("click", function () {
          isBrainSplit = !isBrainSplit;
          updateSplitBrainButton();
          updateBrainVisualization();
        });
      }

      // Set up axes toggle button
      function setupAxesToggle() {
        const toggleButton = document.getElementById("axes-toggle");
        toggleButton.addEventListener("click", function () {
          showAxes = !showAxes;
          updateAxesVisibility();
          updateAxesButton();
        });
      }

      // Update rotation button text based on current state
      function updateRotationButton() {
        const toggleButton = document.getElementById("rotation-toggle");
        if (autoRotate) {
          toggleButton.textContent = "Stop Rotation";
        } else {
          toggleButton.textContent = "Start Rotation";
        }
      }

      // Update split brain button text based on current state
      function updateSplitBrainButton() {
        const toggleButton = document.getElementById("split-brain-toggle");
        if (isBrainSplit) {
          toggleButton.textContent = "Show Full Brain";
        } else {
          toggleButton.textContent = "Split Brain";
        }
      }

      // Update axes toggle button text based on current state
      function updateAxesButton() {
        const toggleButton = document.getElementById("axes-toggle");
        if (showAxes) {
          toggleButton.textContent = "Hide Axes";
        } else {
          toggleButton.textContent = "Show Axes";
        }
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Apply auto-rotation if enabled and user hasn't interacted
        if (autoRotate && brainGroup) {
          // Rotate around the vertical axis for horizontal side-to-side spin
          // Since we've rotated the brain group with brainGroup.rotation.x = -Math.PI / 2,
          // we need to rotate around the z-axis to get a horizontal spin
          brainGroup.rotation.z += 0.005; // Increased rotation speed for better visibility

          // If axes are visible, rotate them with the brain
          if (axesHelper && showAxes) {
            axesHelper.rotation.z = brainGroup.rotation.z;
          }
        }

        controls.update();
        renderer.render(scene, camera);
      }

      // Load coordinates from JSON files
      function loadCoordinates() {
        // First load the whole brain atlas with MNI coordinates
        fetch("whole_brain_mni_coordinates.json")
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                "Network response was not ok for whole brain data"
              );
            }
            return response.json();
          })
          .then((data) => {
            console.log("Loaded brain data:", data);

            // Check if coordinates exist in the data
            if (
              !data.coordinates ||
              !Array.isArray(data.coordinates) ||
              data.coordinates.length === 0
            ) {
              throw new Error(
                "No coordinates found in the data or coordinates is not an array"
              );
            }

            const coordinates = data.coordinates; // Use coordinates instead of voxels

            // Log the first few coordinates to verify format
            console.log("First 5 coordinates:", coordinates.slice(0, 5));

            // Check if shape exists, if not, calculate it from coordinates
            let shape;
            if (data.shape) {
              shape = data.shape;
            } else {
              // For MNI coordinates, we need to calculate the bounding box
              let minX = Infinity,
                minY = Infinity,
                minZ = Infinity;
              let maxX = -Infinity,
                maxY = -Infinity,
                maxZ = -Infinity;

              for (const coord of coordinates) {
                if (!Array.isArray(coord) || coord.length !== 3) {
                  console.error("Invalid coordinate format:", coord);
                  continue;
                }

                const [x, y, z] = coord;
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                minZ = Math.min(minZ, z);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
                maxZ = Math.max(maxZ, z);
              }

              shape = [
                Math.ceil(maxX - minX),
                Math.ceil(maxY - minY),
                Math.ceil(maxZ - minZ),
              ];

              console.log("Calculated shape from coordinates:", shape);
            }

            brainShape = shape; // Store brain shape

            // Update info panel
            document.getElementById(
              "dimensions"
            ).textContent = `${shape[0]} × ${shape[1]} × ${shape[2]}`;

            // Filter to get only surface coordinates
            try {
              brainCoordinates = filterSurfaceCoordinates(coordinates, shape); // Store brain coordinates

              // Create brain volume visualization with only surface coordinates
              createBrainVolume(brainCoordinates, shape);

              // Hide loading message
              document.getElementById("loading").style.display = "none";
            } catch (error) {
              console.error("Error processing coordinates:", error);
              document.getElementById("loading").textContent =
                "Error processing coordinates: " + error.message;
            }
          })
          .catch((error) => {
            console.error("Error loading coordinate data:", error);
            document.getElementById("loading").textContent =
              "Error loading coordinate data: " + error.message;
          });
      }

      // Filter to get only surface coordinates
      function filterSurfaceCoordinates(coordinates, shape) {
        console.log("Filtering surface coordinates...");

        // Validate input
        if (
          !coordinates ||
          !Array.isArray(coordinates) ||
          coordinates.length === 0
        ) {
          throw new Error("Invalid coordinates array");
        }

        // For MNI coordinates, we need to create a spatial hash instead of a 3D array
        // since coordinates can be negative and are floating point values
        const spatialHash = new Map();
        const resolution = 1.0; // Resolution for spatial hashing (1mm)

        // Function to get hash key for a coordinate
        function getHashKey(x, y, z) {
          // Round to nearest resolution unit to handle floating point
          const rx = Math.round(x / resolution);
          const ry = Math.round(y / resolution);
          const rz = Math.round(z / resolution);
          return `${rx},${ry},${rz}`;
        }

        // Add all coordinates to the spatial hash
        for (const coord of coordinates) {
          if (!Array.isArray(coord) || coord.length !== 3) {
            console.warn("Skipping invalid coordinate:", coord);
            continue;
          }

          const [x, y, z] = coord;
          if (
            typeof x !== "number" ||
            typeof y !== "number" ||
            typeof z !== "number" ||
            isNaN(x) ||
            isNaN(y) ||
            isNaN(z)
          ) {
            console.warn("Skipping coordinate with non-numeric values:", coord);
            continue;
          }

          spatialHash.set(getHashKey(x, y, z), true);
        }

        if (spatialHash.size === 0) {
          throw new Error("No valid coordinates found");
        }

        // Find surface coordinates (those with at least one empty neighbor)
        const surfaceCoordinates = [];
        const directions = [
          [1, 0, 0],
          [-1, 0, 0],
          [0, 1, 0],
          [0, -1, 0],
          [0, 0, 1],
          [0, 0, -1],
        ];

        for (const coord of coordinates) {
          if (!Array.isArray(coord) || coord.length !== 3) {
            continue; // Skip invalid coordinates
          }

          const [x, y, z] = coord;
          if (
            typeof x !== "number" ||
            typeof y !== "number" ||
            typeof z !== "number" ||
            isNaN(x) ||
            isNaN(y) ||
            isNaN(z)
          ) {
            continue; // Skip coordinates with non-numeric values
          }

          // Check if this coordinate is on the surface
          let isSurface = false;

          // Check all 6 neighbors
          for (const [dx, dy, dz] of directions) {
            const nx = x + dx * resolution;
            const ny = y + dy * resolution;
            const nz = z + dz * resolution;

            // If neighbor is not in the hash, this is a surface coordinate
            if (!spatialHash.has(getHashKey(nx, ny, nz))) {
              isSurface = true;
              break;
            }
          }

          if (isSurface) {
            surfaceCoordinates.push(coord);
          }
        }

        if (surfaceCoordinates.length === 0) {
          throw new Error("No surface coordinates found");
        }

        console.log(
          `Found ${surfaceCoordinates.length} surface coordinates out of ${
            coordinates.length
          } total coordinates (${Math.round(
            (surfaceCoordinates.length / coordinates.length) * 100
          )}%)`
        );

        return surfaceCoordinates;
      }

      // Create brain volume visualization
      function createBrainVolume(coordinates, shape) {
        console.log("Creating brain volume visualization...");

        // Validate input
        if (
          !coordinates ||
          !Array.isArray(coordinates) ||
          coordinates.length === 0
        ) {
          throw new Error("Invalid coordinates array");
        }

        // Create a group to hold all elements
        brainGroup = new THREE.Group(); // Store reference for rotation

        // For MNI coordinates, we need to calculate the bounding box
        let minX = Infinity,
          minY = Infinity,
          minZ = Infinity;
        let maxX = -Infinity,
          maxY = -Infinity,
          maxZ = -Infinity;

        // Validate coordinates and calculate bounds
        let validCoordinates = [];
        for (const coord of coordinates) {
          if (!Array.isArray(coord) || coord.length !== 3) {
            console.warn("Skipping invalid coordinate:", coord);
            continue;
          }

          const [x, y, z] = coord;
          if (
            typeof x !== "number" ||
            typeof y !== "number" ||
            typeof z !== "number" ||
            isNaN(x) ||
            isNaN(y) ||
            isNaN(z)
          ) {
            console.warn("Skipping coordinate with non-numeric values:", coord);
            continue;
          }

          validCoordinates.push(coord);

          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          minZ = Math.min(minZ, z);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
          maxZ = Math.max(maxZ, z);
        }

        if (validCoordinates.length === 0) {
          throw new Error("No valid coordinates found");
        }

        // Use validated coordinates
        coordinates = validCoordinates;

        // Calculate dimensions and center
        const dimensions = [maxX - minX, maxY - minY, maxZ - minZ];

        const center = [
          (minX + maxX) / 2,
          (minY + maxY) / 2,
          (minZ + maxZ) / 2,
        ];

        console.log("Bounding box:", { minX, minY, minZ, maxX, maxY, maxZ });
        console.log("Center:", center);

        // Store brain shape as dimensions
        brainShape = dimensions;

        // Reorient the brain to be horizontal (neurological convention)
        // This rotates the brain so that anterior is toward the front
        brainGroup.rotation.x = -Math.PI / 2; // Rotate around X-axis to make Y point forward

        try {
          // Create voxels for the brain surface using MNI coordinates
          createBrainVoxels(coordinates, center, brainGroup);

          // Add the brain group to the scene
          scene.add(brainGroup);

          // Set up camera position for a good view
          const maxDim = Math.max(...dimensions);

          // Position camera for an EXTREMELY zoomed-in side view
          // This positions the camera extremely close to the brain from the side (lateral view)
          camera.position.set(maxDim * 0.15, 0, 0); // Extremely close position for maximum zoom

          // Look at the center of the brain
          camera.lookAt(0, 0, 0);
          controls.update();

          // Update coordinate count
          document.getElementById("coordinate-count").textContent =
            coordinates.length;

          // Update dimensions in the info panel
          document.getElementById("dimensions").textContent = `${Math.round(
            dimensions[0]
          )}mm × ${Math.round(dimensions[1])}mm × ${Math.round(
            dimensions[2]
          )}mm`;

          // Add info about orientation to the info panel
          const infoDiv = document.getElementById("info");
          const orientationInfo = document.createElement("p");
          orientationInfo.innerHTML =
            "Orientation: <span style='color:#444444'>X (R→L)</span>, <span style='color:#666666'>Y (A→P)</span>, <span style='color:#888888'>Z (S→I)</span>";
          infoDiv.appendChild(orientationInfo);

          // Add coordinate system info
          const coordinateInfo = document.createElement("p");
          coordinateInfo.innerHTML =
            "Coordinate system: <strong>MNI152</strong>";
          infoDiv.appendChild(coordinateInfo);

          // Add bounding box info
          const boundingInfo = document.createElement("p");
          boundingInfo.innerHTML = `MNI Bounds: X(${Math.round(
            minX
          )} to ${Math.round(maxX)}), Y(${Math.round(minY)} to ${Math.round(
            maxY
          )}), Z(${Math.round(minZ)} to ${Math.round(maxZ)})`;
          infoDiv.appendChild(boundingInfo);

          // Add legend for color coding
          const legend = document.createElement("div");
          legend.className = "legend";
          legend.innerHTML = `
            <p><strong>Legend:</strong></p>
            <p><span class="color-box" style="background-color:#888888"></span> Whole Brain Surface</p>
          `;
          infoDiv.appendChild(legend);

          // Show rotation toggle button after brain is loaded
          document.getElementById("rotation-toggle").style.display = "block";
          document.getElementById("split-brain-toggle").style.display = "block";
          document.getElementById("axes-toggle").style.display = "block";

          // Create axes helper (initially hidden)
          axesHelper = createAxesHelper();
          scene.add(axesHelper);
          updateAxesVisibility();

          // Ensure auto-rotation is enabled initially
          autoRotate = true;
          updateRotationButton();
        } catch (error) {
          console.error("Error creating brain visualization:", error);
          document.getElementById("loading").textContent =
            "Error creating brain visualization: " + error.message;
        }
      }

      // Create voxels for the brain surface using MNI coordinates
      function createBrainVoxels(coordinates, center, brainGroup) {
        console.log(
          `Creating voxels for ${coordinates.length} surface coordinates...`
        );

        // Validate input
        if (
          !coordinates ||
          !Array.isArray(coordinates) ||
          coordinates.length === 0
        ) {
          throw new Error("Invalid coordinates array");
        }

        if (!center || !Array.isArray(center) || center.length !== 3) {
          throw new Error("Invalid center point");
        }

        // Create a box for each coordinate
        const boxSize = 0.92; // Slightly smaller to create visible gaps
        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

        // Create a material that better shows the brain's contours with grayscale theme
        const material = new THREE.MeshStandardMaterial({
          color: 0x888888,
          roughness: 0.7,
          metalness: 0.1,
          transparent: false,
          side: THREE.FrontSide,
          flatShading: true,
        });

        // Filter coordinates based on split brain state
        const filteredCoordinates = isBrainSplit
          ? coordinates.filter(
              (coord) =>
                Array.isArray(coord) && coord.length === 3 && coord[0] <= 0
            ) // In MNI, midline is at x=0
          : coordinates.filter(
              (coord) => Array.isArray(coord) && coord.length === 3
            );

        if (filteredCoordinates.length === 0) {
          throw new Error("No valid coordinates after filtering");
        }

        console.log(
          `Using ${filteredCoordinates.length} coordinates after filtering`
        );

        // Use instanced mesh for better performance
        brainInstancedMesh = new THREE.InstancedMesh(
          boxGeometry,
          material,
          filteredCoordinates.length
        );

        // Set matrix for each instance
        const matrix = new THREE.Matrix4();
        const scale = 0.1; // Scale factor to make the brain a reasonable size

        for (let i = 0; i < filteredCoordinates.length; i++) {
          const coord = filteredCoordinates[i];
          const [x, y, z] = coord;

          // Position relative to center and scale down for better visualization
          // MNI coordinates are in mm, so we scale down by a factor to fit in the scene
          const posX = (x - center[0]) * scale;
          const posY = (y - center[1]) * scale;
          const posZ = (z - center[2]) * scale;

          matrix.setPosition(posX, posY, posZ);
          brainInstancedMesh.setMatrixAt(i, matrix);

          // Set color based on height (Y in MNI) with more subtle grayscale tones
          // Higher Y values (more anterior) will be lighter
          const yRange = 200; // Approximate range of Y values in MNI
          const heightRatio = (y + 100) / yRange; // Normalize to 0-1 range
          const grayValue = 0.5 + 0.3 * heightRatio; // Adjust for good contrast
          const color = new THREE.Color(grayValue, grayValue, grayValue);
          brainInstancedMesh.setColorAt(i, color);
        }

        // Update instance matrix and colors
        brainInstancedMesh.instanceMatrix.needsUpdate = true;
        if (brainInstancedMesh.instanceColor) {
          brainInstancedMesh.instanceColor.needsUpdate = true;
        }

        // Add the voxels to the brain group
        brainGroup.add(brainInstancedMesh);

        // Add edges with reduced number (only some voxels get edges)
        createSimplifiedEdges(filteredCoordinates, center, brainGroup);

        console.log(
          "Surface coordinates rendered with enhanced lighting for gyri visibility"
        );
      }

      // Create simplified edges (only for some coordinates)
      function createSimplifiedEdges(coordinates, center, brainGroup) {
        console.log("Creating simplified edges...");

        // Validate input
        if (
          !coordinates ||
          !Array.isArray(coordinates) ||
          coordinates.length === 0
        ) {
          console.warn(
            "Invalid coordinates array for edges, skipping edge creation"
          );
          return;
        }

        if (!center || !Array.isArray(center) || center.length !== 3) {
          console.warn(
            "Invalid center point for edges, skipping edge creation"
          );
          return;
        }

        // Create a merged geometry for edges
        const edgePositions = [];

        // Create a box geometry for reference
        const boxSize = 0.92;
        const halfSize = boxSize / 2;

        // Define the 12 edges of a cube
        const edgeDefinitions = [
          // Bottom face
          [-halfSize, -halfSize, -halfSize, halfSize, -halfSize, -halfSize],
          [halfSize, -halfSize, -halfSize, halfSize, -halfSize, halfSize],
          [halfSize, -halfSize, halfSize, -halfSize, -halfSize, halfSize],
          [-halfSize, -halfSize, halfSize, -halfSize, -halfSize, -halfSize],

          // Top face
          [-halfSize, halfSize, -halfSize, halfSize, halfSize, -halfSize],
          [halfSize, halfSize, -halfSize, halfSize, halfSize, halfSize],
          [halfSize, halfSize, halfSize, -halfSize, halfSize, halfSize],
          [-halfSize, halfSize, halfSize, -halfSize, halfSize, -halfSize],

          // Connecting edges
          [-halfSize, -halfSize, -halfSize, -halfSize, halfSize, -halfSize],
          [halfSize, -halfSize, -halfSize, halfSize, halfSize, -halfSize],
          [halfSize, -halfSize, halfSize, halfSize, halfSize, halfSize],
          [-halfSize, -halfSize, halfSize, -halfSize, halfSize, halfSize],
        ];

        // Only add edges for coordinates at regular intervals (reduces number of edges)
        const edgeInterval = 4; // Only show edges for every 4th coordinate
        const scale = 0.1; // Same scale factor as in createBrainVoxels

        let edgeCount = 0;
        for (let i = 0; i < coordinates.length; i++) {
          // Skip some coordinates to reduce edge count
          if (i % edgeInterval !== 0) continue;

          const coord = coordinates[i];
          if (!Array.isArray(coord) || coord.length !== 3) {
            continue; // Skip invalid coordinates
          }

          const [x, y, z] = coord;
          if (
            typeof x !== "number" ||
            typeof y !== "number" ||
            typeof z !== "number" ||
            isNaN(x) ||
            isNaN(y) ||
            isNaN(z)
          ) {
            continue; // Skip coordinates with non-numeric values
          }

          // Position relative to center and scale down
          const posX = (x - center[0]) * scale;
          const posY = (y - center[1]) * scale;
          const posZ = (z - center[2]) * scale;

          // Add each edge
          for (const [x1, y1, z1, x2, y2, z2] of edgeDefinitions) {
            edgePositions.push(
              posX + x1,
              posY + y1,
              posZ + z1,
              posX + x2,
              posY + y2,
              posZ + z2
            );
          }

          edgeCount++;
        }

        if (edgePositions.length === 0) {
          console.warn("No valid edges created, skipping edge rendering");
          return;
        }

        console.log(`Created edges for ${edgeCount} coordinates`);

        // Create the geometry
        const edgeGeometry = new THREE.BufferGeometry();
        edgeGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(edgePositions, 3)
        );

        // Create the material - thinner, semi-transparent edges
        const edgeMaterial = new THREE.LineBasicMaterial({
          color: 0x000000,
          linewidth: 1,
          transparent: true,
          opacity: 0.2, // More subtle edges
        });

        // Create the line segments
        brainEdges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
        brainGroup.add(brainEdges);

        console.log("Added simplified edges to selected coordinates");
      }

      // Update brain visualization based on split state
      function updateBrainVisualization() {
        // Remove existing meshes
        if (brainInstancedMesh) brainGroup.remove(brainInstancedMesh);
        if (brainEdges) brainGroup.remove(brainEdges);

        // Remove all active area meshes
        for (const areaName in activeAreas) {
          if (activeAreas[areaName].mesh) {
            brainGroup.remove(activeAreas[areaName].mesh);
          }
        }

        // Calculate center of brain coordinates
        let minX = Infinity,
          minY = Infinity,
          minZ = Infinity;
        let maxX = -Infinity,
          maxY = -Infinity,
          maxZ = -Infinity;

        for (const coord of brainCoordinates) {
          const [x, y, z] = coord;
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          minZ = Math.min(minZ, z);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
          maxZ = Math.max(maxZ, z);
        }

        const center = [
          (minX + maxX) / 2,
          (minY + maxY) / 2,
          (minZ + maxZ) / 2,
        ];

        // Recreate brain coordinates with filtered data
        createBrainVoxels(brainCoordinates, center, brainGroup);

        // Recreate all active areas
        for (const areaName in activeAreas) {
          if (activeAreas[areaName].active) {
            addAreaVoxels(
              areaName,
              activeAreas[areaName].voxels,
              center,
              areaColors[areaName]
            );
          }
        }

        console.log(`Brain visualization updated. Split mode: ${isBrainSplit}`);
      }

      // New function to load available areas
      function loadAvailableAreas() {
        // Fetch the list of available area JSON files from index.json
        fetch("index2.json")
          .then((response) => {
            if (!response.ok) {
              throw new Error("Could not load index.json");
            }
            return response.json();
          })
          .then((data) => {
            // Convert the areas from index.json format to our application format
            availableAreas = data.areas.map((area, index) => {
              return {
                name: area.name,
                file: `brodmann_areas/${area.mni_filename}`, // Use mni_filename instead of voxel_filename
                description: area.name,
                index: area.index,
              };
            });

            // Initialize area colors
            availableAreas.forEach((area, index) => {
              // Assign a color from the palette, cycling if needed
              areaColors[area.name] = colorPalette[index % colorPalette.length];
            });

            // Populate the area list
            updateAreaList();
          })
          .catch((error) => {
            console.error("Error loading index.json:", error);

            // If index.json doesn't exist or has issues, create a fallback with known areas
            console.log("Using fallback area list");
            availableAreas = [
              {
                name: "dlpfc",
                file: "dlpfc_mni_coordinates.json", // Updated to MNI coordinates
                description: "Dorsolateral Prefrontal Cortex",
              },
              {
                name: "broca",
                file: "broca_mni_coordinates.json", // Updated to MNI coordinates
                description: "Broca's Area",
              },
            ];

            // Initialize area colors for fallback
            availableAreas.forEach((area, index) => {
              areaColors[area.name] = colorPalette[index % colorPalette.length];
            });

            // Populate the area list with fallback data
            updateAreaList();
          });
      }

      // Function to update the area list in the UI
      function updateAreaList(searchTerm = "") {
        const areaList = document.getElementById("area-list");
        areaList.innerHTML = ""; // Clear existing list

        // Filter areas based on search term
        const filteredAreas = searchTerm
          ? availableAreas.filter(
              (area) =>
                area.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                (area.description &&
                  area.description
                    .toLowerCase()
                    .includes(searchTerm.toLowerCase()))
            )
          : availableAreas;

        if (filteredAreas.length === 0) {
          areaList.innerHTML =
            '<div class="no-areas-found">No areas found matching your search</div>';
          return;
        }

        // Create checkbox for each area
        filteredAreas.forEach((area) => {
          const areaItem = document.createElement("div");
          areaItem.className = "area-item";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "area-checkbox";
          checkbox.id = `area-${area.name}`;
          checkbox.checked = activeAreas[area.name]?.active || false;
          checkbox.addEventListener("change", () => toggleArea(area));

          const colorBox = document.createElement("span");
          colorBox.className = "area-color";
          colorBox.style.backgroundColor = `#${areaColors[area.name]
            .toString(16)
            .padStart(6, "0")}`;

          const label = document.createElement("label");
          label.htmlFor = `area-${area.name}`;
          label.textContent = area.description || area.name;

          areaItem.appendChild(checkbox);
          areaItem.appendChild(colorBox);
          areaItem.appendChild(label);
          areaList.appendChild(areaItem);
        });
      }

      // Function to set up area search
      function setupAreaSearch() {
        const searchInput = document.getElementById("area-search");
        searchInput.addEventListener("input", (e) => {
          updateAreaList(e.target.value);
        });
      }

      // Function to toggle an area on/off
      function toggleArea(area) {
        const checkbox = document.getElementById(`area-${area.name}`);
        const isActive = checkbox.checked;

        if (
          isActive &&
          (!activeAreas[area.name] || !activeAreas[area.name].voxels)
        ) {
          // Area is being activated and we don't have the data yet
          loadAreaData(area);
        } else if (activeAreas[area.name]) {
          // We already have the data, just toggle visibility
          activeAreas[area.name].active = isActive;

          if (isActive) {
            // Add the area to visualization
            addAreaVoxels(
              area.name,
              activeAreas[area.name].voxels,
              activeAreas[area.name].shape,
              areaColors[area.name]
            );
          } else {
            // Remove the area from visualization
            if (activeAreas[area.name].mesh) {
              brainGroup.remove(activeAreas[area.name].mesh);
              activeAreas[area.name].mesh = null;
            }
          }

          // Update the legend
          updateLegend();
        }
      }

      // Function to load area data
      function loadAreaData(area) {
        console.log(`Loading data for ${area.name}...`);

        // Show loading indicator
        const loadingDiv = document.getElementById("loading");
        loadingDiv.textContent = `Loading ${area.description || area.name}...`;
        loadingDiv.style.display = "block";

        fetch(area.file)
          .then((response) => {
            if (!response.ok) {
              throw new Error(`Could not load data for ${area.name}`);
            }
            return response.json();
          })
          .then((data) => {
            // Calculate center of brain coordinates for positioning
            let minX = Infinity,
              minY = Infinity,
              minZ = Infinity;
            let maxX = -Infinity,
              maxY = -Infinity,
              maxZ = -Infinity;

            for (const coord of brainCoordinates) {
              const [x, y, z] = coord;
              minX = Math.min(minX, x);
              minY = Math.min(minY, y);
              minZ = Math.min(minZ, z);
              maxX = Math.max(maxX, x);
              maxY = Math.max(maxY, y);
              maxZ = Math.max(maxZ, z);
            }

            const center = [
              (minX + maxX) / 2,
              (minY + maxY) / 2,
              (minZ + maxZ) / 2,
            ];

            // Store the area data - check for coordinates key first (MNI format), then voxels (old format)
            activeAreas[area.name] = {
              active: true,
              voxels: data.coordinates || data.voxels, // Support both coordinates and voxels keys
              center: center,
              mesh: null,
            };

            // Add the area to visualization
            addAreaVoxels(
              area.name,
              activeAreas[area.name].voxels,
              center,
              areaColors[area.name]
            );

            // Update the legend
            updateLegend();

            // Hide loading indicator
            loadingDiv.style.display = "none";
          })
          .catch((error) => {
            console.error(`Error loading ${area.name} data:`, error);

            // Uncheck the checkbox
            const checkbox = document.getElementById(`area-${area.name}`);
            checkbox.checked = false;

            // Show error message
            loadingDiv.textContent = `Error loading ${
              area.description || area.name
            }. Check console for details.`;
            setTimeout(() => {
              loadingDiv.style.display = "none";
            }, 3000);
          });
      }

      // Function to add area voxels to the visualization
      function addAreaVoxels(areaName, coordinates, center, color) {
        console.log(
          `Adding ${coordinates.length} coordinates for ${areaName}...`
        );

        // Filter coordinates based on split brain state
        const filteredCoordinates = isBrainSplit
          ? coordinates.filter((coord) => coord[0] <= 0) // In MNI, midline is at x=0
          : coordinates;

        // Create a box for each coordinate
        const boxSize = 0.92; // Same size as main brain voxels
        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

        // Create a material for the area coordinates
        const material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.6,
          metalness: 0.2,
          transparent: false,
          side: THREE.FrontSide,
          flatShading: true,
          emissive: new THREE.Color(color).multiplyScalar(0.3), // Slight emissive glow
          emissiveIntensity: 0.3,
        });

        // Use instanced mesh for better performance
        const instancedMesh = new THREE.InstancedMesh(
          boxGeometry,
          material,
          filteredCoordinates.length
        );

        // Set matrix for each instance
        const matrix = new THREE.Matrix4();
        const scale = 0.1; // Same scale factor as in createBrainVoxels

        for (let i = 0; i < filteredCoordinates.length; i++) {
          const coord = filteredCoordinates[i];
          const [x, y, z] = coord;

          // Position relative to center and scale down
          const posX = (x - center[0]) * scale;
          const posY = (y - center[1]) * scale;
          const posZ = (z - center[2]) * scale;

          matrix.setPosition(posX, posY, posZ);
          instancedMesh.setMatrixAt(i, matrix);
        }

        // Update instance matrix
        instancedMesh.instanceMatrix.needsUpdate = true;

        // Add the area coordinates to the brain group
        brainGroup.add(instancedMesh);

        // Store reference to the mesh
        activeAreas[areaName].mesh = instancedMesh;

        console.log(`${areaName} coordinates added with custom color`);
      }

      // Function to update the legend based on active areas
      function updateLegend() {
        const legend = document.querySelector(".legend");
        legend.innerHTML = `
          <p><strong>Legend:</strong></p>
          <p><span class="color-box" style="background-color:#888888"></span> Whole Brain Surface</p>
        `;

        // Add axes information if visible
        if (showAxes) {
          legend.innerHTML += `
            <p><strong>Coordinate Axes:</strong></p>
            <p><span class="color-box" style="background-color:#cc0000"></span> X-axis (Left/Right)</p>
            <p><span class="color-box" style="background-color:#00cc00"></span> Y-axis (Anterior/Posterior)</p>
            <p><span class="color-box" style="background-color:#0000cc"></span> Z-axis (Superior/Inferior)</p>
          `;
        }

        // Add active areas to legend
        for (const areaName in activeAreas) {
          if (activeAreas[areaName].active) {
            const area = availableAreas.find((a) => a.name === areaName);
            const description = area ? area.description || areaName : areaName;
            const colorHex = `#${areaColors[areaName]
              .toString(16)
              .padStart(6, "0")}`;

            legend.innerHTML += `
              <p><span class="color-box" style="background-color:${colorHex}"></span> ${description}</p>
            `;
          }
        }
      }

      // Create and add axes helper to the scene
      function createAxesHelper() {
        // Create a custom axes helper that's more subtle than the default
        const axesGroup = new THREE.Group();

        // Create the three axes with custom colors and size
        const axisLength = 15; // Slightly shorter axes
        const axisThickness = 0.4; // Thinner axes for subtlety

        // X-axis (red) - Left/Right
        const xAxisGeometry = new THREE.CylinderGeometry(
          axisThickness,
          axisThickness,
          axisLength,
          8
        );
        const xAxisMaterial = new THREE.MeshBasicMaterial({
          color: 0xcc0000,
          transparent: true,
          opacity: 0.8,
        });
        const xAxis = new THREE.Mesh(xAxisGeometry, xAxisMaterial);
        xAxis.rotation.z = -Math.PI / 2; // Rotate to align with x-axis
        xAxis.position.x = axisLength / 2; // Position at origin with length extending in positive direction

        // Y-axis (green) - Anterior/Posterior
        const yAxisGeometry = new THREE.CylinderGeometry(
          axisThickness,
          axisThickness,
          axisLength,
          8
        );
        const yAxisMaterial = new THREE.MeshBasicMaterial({
          color: 0x00cc00,
          transparent: true,
          opacity: 0.8,
        });
        const yAxis = new THREE.Mesh(yAxisGeometry, yAxisMaterial);
        yAxis.position.y = axisLength / 2; // Position at origin with length extending in positive direction

        // Z-axis (blue) - Superior/Inferior
        const zAxisGeometry = new THREE.CylinderGeometry(
          axisThickness,
          axisThickness,
          axisLength,
          8
        );
        const zAxisMaterial = new THREE.MeshBasicMaterial({
          color: 0x0000cc,
          transparent: true,
          opacity: 0.8,
        });
        const zAxis = new THREE.Mesh(zAxisGeometry, zAxisMaterial);
        zAxis.rotation.x = Math.PI / 2; // Rotate to align with z-axis
        zAxis.position.z = axisLength / 2; // Position at origin with length extending in positive direction

        // Add labels for each axis
        const createLabel = (text, position, color) => {
          const canvas = document.createElement("canvas");
          canvas.width = 64;
          canvas.height = 32;
          const context = canvas.getContext("2d");
          context.fillStyle = color;
          context.font = "24px Arial";
          context.fillText(text, 0, 24);

          const texture = new THREE.CanvasTexture(canvas);
          const material = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
          });
          const sprite = new THREE.Sprite(material);
          sprite.position.copy(position);
          sprite.scale.set(5, 2.5, 1);
          return sprite;
        };

        // Add labels at the end of each axis
        const xLabel = createLabel(
          "X",
          new THREE.Vector3(axisLength + 2, 0, 0),
          "#cc0000"
        );
        const yLabel = createLabel(
          "Y",
          new THREE.Vector3(0, axisLength + 2, 0),
          "#00cc00"
        );
        const zLabel = createLabel(
          "Z",
          new THREE.Vector3(0, 0, axisLength + 2),
          "#0000cc"
        );

        // Add all elements to the axes group
        axesGroup.add(xAxis);
        axesGroup.add(yAxis);
        axesGroup.add(zAxis);
        axesGroup.add(xLabel);
        axesGroup.add(yLabel);
        axesGroup.add(zLabel);

        // Position the axes at the origin (0,0,0) in the scene
        // This will align it properly with the brain
        axesGroup.position.set(0, 0, 0);

        // Apply the same rotation as the brain group to maintain correct orientation
        axesGroup.rotation.x = -Math.PI / 2;

        // Initially hide the axes
        axesGroup.visible = showAxes;

        return axesGroup;
      }

      // Update axes visibility based on toggle state
      function updateAxesVisibility() {
        if (!axesHelper) {
          // Create axes helper if it doesn't exist
          axesHelper = createAxesHelper();
          scene.add(axesHelper);
        }

        // Update visibility
        axesHelper.visible = showAxes;

        // Ensure axes have the same rotation as the brain group
        if (brainGroup && axesHelper) {
          // Keep the base rotation (x rotation) the same
          axesHelper.rotation.x = -Math.PI / 2;
          // But sync the z rotation with the brain for auto-rotation
          axesHelper.rotation.z = brainGroup.rotation.z;

          // Position the axes at a fixed offset from the center
          // With extreme zoom, we need to position them closer to the center
          axesHelper.position.set(-2, -2, -2);
        }

        // Update the legend to include/exclude axes information
        updateLegend();
      }

      // Initialize and start animation
      init();
      animate();
    </script>
  </body>
</html>
