<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Brain Voxel Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #333;
        font-family: Arial, sans-serif;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
      }
      .color-box {
        display: inline-block;
        width: 15px;
        height: 15px;
        margin-right: 5px;
        border: 1px solid #666;
        vertical-align: middle;
      }
      .legend {
        margin-top: 10px;
        padding-top: 10px;
        border-top: 1px solid #ccc;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: Arial, sans-serif;
        font-size: 24px;
        color: #333;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 10px;
        z-index: 100;
      }
      #rotation-toggle,
      #split-brain-toggle {
        position: absolute;
        bottom: 20px;
        padding: 10px 15px;
        background-color: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 5px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      #rotation-toggle {
        left: 20px;
      }
      #split-brain-toggle {
        left: 150px;
      }
      #rotation-toggle:hover,
      #split-brain-toggle:hover {
        background-color: rgba(240, 240, 240, 0.9);
      }
      /* New styles for area controls */
      #area-controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
        max-height: 80vh;
        overflow-y: auto;
        font-family: Arial, sans-serif;
      }
      #area-search {
        width: 100%;
        padding: 5px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }
      .area-item {
        margin: 5px 0;
        display: flex;
        align-items: center;
      }
      .area-checkbox {
        margin-right: 8px;
      }
      .area-color {
        width: 15px;
        height: 15px;
        display: inline-block;
        margin-right: 8px;
        border: 1px solid #666;
      }
      .no-areas-found {
        color: #666;
        font-style: italic;
        margin-top: 10px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h2>3D Brain Voxel Visualization</h2>
      <p>Loading voxels: <span id="voxel-count">0</span></p>
      <p>Brain dimensions: <span id="dimensions">Loading...</span></p>
      <p>
        Controls: Left-click + drag to rotate, scroll to zoom, right-click +
        drag to pan
      </p>
    </div>
    <div id="loading">Loading brain voxels...</div>
    <button id="rotation-toggle">Stop Rotation</button>
    <button id="split-brain-toggle">Split Brain</button>

    <!-- New area controls panel -->
    <div id="area-controls">
      <h3>Brain Areas</h3>
      <input type="text" id="area-search" placeholder="Search areas..." />
      <div id="area-list">
        <!-- Area checkboxes will be added here dynamically -->
      </div>
    </div>

    <script>
      // Main Three.js variables
      let scene, camera, renderer, controls;
      let voxelCount = 0;
      let brainGroup; // Store reference to the brain group for rotation
      let autoRotate = true; // Auto-rotation state
      let userInteracted = false; // Track if user has interacted with controls
      let isBrainSplit = false; // Track if brain is split
      let brainVoxels = []; // Store brain voxel data
      let brainShape = []; // Store brain dimensions
      let brainInstancedMesh; // Reference to brain instanced mesh
      let brainEdges; // Reference to brain edges

      // New variables for general area handling
      let availableAreas = []; // List of available areas
      let activeAreas = {}; // Map of active areas and their meshes
      let areaColors = {}; // Map of area colors

      // Color palette for different areas
      const colorPalette = [
        0x00aa00, // Green
        0x0055aa, // Blue
        0xaa0000, // Red
        0xaa00aa, // Purple
        0xaaaa00, // Yellow
        0x00aaaa, // Cyan
        0xff5500, // Orange
        0x5500ff, // Indigo
        0xff0055, // Pink
        0x55ff00, // Lime
      ];

      // Initialize the scene
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.set(100, 100, 100);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls for interaction
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;
        controls.screenSpacePanning = true; // Enable proper panning
        controls.minDistance = 10;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI; // Allow full vertical rotation
        controls.rotateSpeed = 0.7; // Adjust rotation speed

        // Add event listeners to detect user interaction with controls
        controls.addEventListener("start", function () {
          if (autoRotate) {
            userInteracted = true;
            autoRotate = false;
            updateRotationButton();
          }
        });

        // Enhanced lighting setup for more balanced illumination
        // Increase ambient light for better overall visibility
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        // Main directional light from top-right-front
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
        mainLight.position.set(1, 1, 1);
        scene.add(mainLight);

        // Back light to illuminate the posterior part of the brain
        const backLight = new THREE.DirectionalLight(0xffffff, 0.5);
        backLight.position.set(-0.5, 0.5, -1);
        scene.add(backLight);

        // Bottom light for additional fill
        const bottomLight = new THREE.DirectionalLight(0xffffff, 0.3);
        bottomLight.position.set(0, -1, 0);
        scene.add(bottomLight);

        // Top light for additional illumination
        const topLight = new THREE.DirectionalLight(0xffffff, 0.3);
        topLight.position.set(0, 1, 0);
        scene.add(topLight);

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);

        // Set up rotation toggle button
        setupRotationToggle();

        // Set up split brain toggle button
        setupSplitBrainToggle();

        // Set up area search functionality
        setupAreaSearch();

        // Load and visualize voxels
        loadVoxels();

        // Load available areas
        loadAvailableAreas();
      }

      // Set up rotation toggle button
      function setupRotationToggle() {
        const toggleButton = document.getElementById("rotation-toggle");
        toggleButton.addEventListener("click", function () {
          autoRotate = !autoRotate;
          if (autoRotate) {
            userInteracted = false; // Reset interaction flag when manually starting rotation
          }
          updateRotationButton();
        });
      }

      // Set up split brain toggle button
      function setupSplitBrainToggle() {
        const toggleButton = document.getElementById("split-brain-toggle");
        toggleButton.addEventListener("click", function () {
          isBrainSplit = !isBrainSplit;
          updateSplitBrainButton();
          updateBrainVisualization();
        });
      }

      // Update rotation button text based on current state
      function updateRotationButton() {
        const toggleButton = document.getElementById("rotation-toggle");
        if (autoRotate) {
          toggleButton.textContent = "Stop Rotation";
        } else {
          toggleButton.textContent = "Start Rotation";
        }
      }

      // Update split brain button text based on current state
      function updateSplitBrainButton() {
        const toggleButton = document.getElementById("split-brain-toggle");
        if (isBrainSplit) {
          toggleButton.textContent = "Show Full Brain";
        } else {
          toggleButton.textContent = "Split Brain";
        }
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Apply auto-rotation if enabled and user hasn't interacted
        if (autoRotate && brainGroup) {
          // Rotate around the vertical axis (y-axis) for horizontal side-to-side spin
          // Note: Since we've rotated the brain group with brainGroup.rotation.x = -Math.PI / 2,
          // we need to rotate around the z-axis to get a horizontal spin
          brainGroup.rotation.z += 0.001; // Very slow horizontal rotation
        }

        controls.update();
        renderer.render(scene, camera);
      }

      // Load voxels from JSON files
      function loadVoxels() {
        // First load the whole brain atlas
        fetch("whole_brain_atlas_voxels.json")
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                "Network response was not ok for whole brain data"
              );
            }
            return response.json();
          })
          .then((data) => {
            const voxels = data.voxels;
            const shape = data.shape;
            brainShape = shape; // Store brain shape

            // Update info panel
            document.getElementById(
              "dimensions"
            ).textContent = `${shape[0]} × ${shape[1]} × ${shape[2]}`;

            // Filter to get only surface voxels
            brainVoxels = filterSurfaceVoxels(voxels, shape); // Store brain voxels

            // Create brain volume visualization with only surface voxels
            createBrainVolume(brainVoxels, shape);

            // Hide loading message
            document.getElementById("loading").style.display = "none";

            /* Comment out specific area loading
            // Now load the DLPFC atlas
            return fetch("dlpfc_atlas_voxels.json");
          })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok for DLPFC data");
            }
            return response.json();
          })
          .then((dlpfcData) => {
            // Store DLPFC data
            dlpfcVoxels = dlpfcData.voxels;
            dlpfcShape = dlpfcData.shape;

            // Add DLPFC voxels to the visualization
            addDLPFCVoxels(dlpfcVoxels, dlpfcShape);

            // Update info panel with DLPFC count
            const infoDiv = document.getElementById("info");
            const dlpfcInfo = document.createElement("p");
            dlpfcInfo.innerHTML = `DLPFC voxels: <span style="color:#00aa00">${dlpfcData.voxels.length}</span>`;
            infoDiv.appendChild(dlpfcInfo);

            // Now load the Broca's area atlas
            return fetch("broca_atlas_voxels.json");
          })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                "Network response was not ok for Broca's area data"
              );
            }
            return response.json();
          })
          .then((brocaData) => {
            // Store Broca's area data
            brocaVoxels = brocaData.voxels;
            brocaShape = brocaData.shape;

            // Add Broca's area voxels to the visualization
            addBrocaVoxels(brocaVoxels, brocaShape);

            // Update info panel with Broca's area count
            const infoDiv = document.getElementById("info");
            const brocaInfo = document.createElement("p");
            brocaInfo.innerHTML = `Broca's area voxels: <span style="color:#0055aa">${brocaData.voxels.length}</span>`;
            infoDiv.appendChild(brocaInfo);

            // Hide loading message
            document.getElementById("loading").style.display = "none";
            */
          })
          .catch((error) => {
            console.error("Error loading voxel data:", error);
            document.getElementById("loading").textContent =
              "Error loading voxel data. Check console for details.";
          });
      }

      // Filter to get only surface voxels
      function filterSurfaceVoxels(voxels, shape) {
        console.log("Filtering surface voxels...");

        // Create a 3D array to represent the brain volume
        const volume = Array(shape[0])
          .fill()
          .map(() =>
            Array(shape[1])
              .fill()
              .map(() => Array(shape[2]).fill(false))
          );

        // Fill the volume with the voxels
        for (const voxel of voxels) {
          const [x, y, z] = voxel;
          if (
            x >= 0 &&
            x < shape[0] &&
            y >= 0 &&
            y < shape[1] &&
            z >= 0 &&
            z < shape[2]
          ) {
            volume[x][y][z] = true;
          }
        }

        // Find surface voxels (those with at least one empty neighbor)
        const surfaceVoxels = [];
        const directions = [
          [1, 0, 0],
          [-1, 0, 0],
          [0, 1, 0],
          [0, -1, 0],
          [0, 0, 1],
          [0, 0, -1],
        ];

        for (const voxel of voxels) {
          const [x, y, z] = voxel;

          // Check if this voxel is on the surface
          let isSurface = false;

          // If it's on the edge of the volume, it's definitely a surface voxel
          if (
            x === 0 ||
            x === shape[0] - 1 ||
            y === 0 ||
            y === shape[1] - 1 ||
            z === 0 ||
            z === shape[2] - 1
          ) {
            isSurface = true;
          } else {
            // Check all 6 neighbors
            for (const [dx, dy, dz] of directions) {
              const nx = x + dx;
              const ny = y + dy;
              const nz = z + dz;

              // If neighbor is out of bounds or empty, this is a surface voxel
              if (
                nx < 0 ||
                nx >= shape[0] ||
                ny < 0 ||
                ny >= shape[1] ||
                nz < 0 ||
                nz >= shape[2] ||
                !volume[nx][ny][nz]
              ) {
                isSurface = true;
                break;
              }
            }
          }

          if (isSurface) {
            surfaceVoxels.push(voxel);
          }
        }

        console.log(
          `Found ${surfaceVoxels.length} surface voxels out of ${
            voxels.length
          } total voxels (${Math.round(
            (surfaceVoxels.length / voxels.length) * 100
          )}%)`
        );

        return surfaceVoxels;
      }

      // Create brain volume visualization
      function createBrainVolume(voxels, shape) {
        // Create a group to hold all elements
        brainGroup = new THREE.Group(); // Store reference for rotation

        // Calculate center offset to center the brain
        const centerOffset = [-shape[0] / 2, -shape[1] / 2, -shape[2] / 2];

        // Reorient the brain to be horizontal (neurological convention)
        // This rotates the brain so that anterior is toward the front
        brainGroup.rotation.x = -Math.PI / 2; // Rotate around X-axis to make Y point forward

        // Create voxels for the brain surface
        createBrainVoxels(voxels, shape, centerOffset, brainGroup);

        // Add the brain group to the scene
        scene.add(brainGroup);

        // Set up camera position for a good top-front-side view of the brain
        const maxDim = Math.max(...shape);

        // Position camera for a more zoomed-in top-front-side view
        // X: positive (right side of brain)
        // Y: positive (above brain)
        // Z: negative (in front of brain)
        camera.position.set(maxDim * 0.8, maxDim * 0.7, -maxDim * 0.6);

        // Look at the center of the brain
        camera.lookAt(0, 0, 0);
        controls.update();

        // Update voxel count
        document.getElementById("voxel-count").textContent = voxels.length;

        // Add info about orientation to the info panel
        const infoDiv = document.getElementById("info");
        const orientationInfo = document.createElement("p");
        orientationInfo.innerHTML =
          "Orientation: <span style='color:#444444'>X (R→L)</span>, <span style='color:#666666'>Y (A→P)</span>, <span style='color:#888888'>Z (S→I)</span>";
        infoDiv.appendChild(orientationInfo);

        // Add legend for color coding
        const legend = document.createElement("div");
        legend.className = "legend";
        legend.innerHTML = `
          <p><strong>Legend:</strong></p>
          <p><span class="color-box" style="background-color:#888888"></span> Whole Brain Surface</p>
        `;
        infoDiv.appendChild(legend);

        // Show rotation toggle button after brain is loaded
        document.getElementById("rotation-toggle").style.display = "block";
        document.getElementById("split-brain-toggle").style.display = "block";
      }

      // Create voxels for the brain surface
      function createBrainVoxels(voxels, shape, centerOffset, brainGroup) {
        console.log(
          `Creating voxels for ${voxels.length} surface coordinates...`
        );

        // Create a box for each voxel
        const boxSize = 0.92; // Slightly smaller to create visible gaps
        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

        // Create a material that better shows the brain's contours with grayscale theme
        // and responds well to omnidirectional lighting
        const material = new THREE.MeshStandardMaterial({
          color: 0x888888,
          roughness: 0.7,
          metalness: 0.1,
          transparent: false,
          side: THREE.FrontSide,
          flatShading: true,
        });

        // Filter voxels based on split brain state
        const filteredVoxels = isBrainSplit
          ? voxels.filter((voxel) => voxel[0] <= shape[0] / 2)
          : voxels;

        // Use instanced mesh for better performance
        brainInstancedMesh = new THREE.InstancedMesh(
          boxGeometry,
          material,
          filteredVoxels.length
        );

        // Set matrix for each instance
        const matrix = new THREE.Matrix4();
        for (let i = 0; i < filteredVoxels.length; i++) {
          const voxel = filteredVoxels[i];
          const [x, y, z] = voxel;

          matrix.setPosition(
            x + centerOffset[0],
            y + centerOffset[1],
            z + centerOffset[2]
          );

          brainInstancedMesh.setMatrixAt(i, matrix);

          // Set color based on height with more subtle grayscale tones
          const heightRatio = y / shape[1];
          // Create grayscale value with less variation for more uniform appearance
          const grayValue = 0.6 + 0.2 * heightRatio;
          const color = new THREE.Color(grayValue, grayValue, grayValue);
          brainInstancedMesh.setColorAt(i, color);
        }

        // Update instance matrix and colors
        brainInstancedMesh.instanceMatrix.needsUpdate = true;
        if (brainInstancedMesh.instanceColor) {
          brainInstancedMesh.instanceColor.needsUpdate = true;
        }

        // Add the voxels to the brain group
        brainGroup.add(brainInstancedMesh);

        // Add edges with reduced number (only some voxels get edges)
        createSimplifiedEdges(filteredVoxels, shape, centerOffset, brainGroup);

        console.log(
          "Surface voxels rendered with enhanced lighting for gyri visibility"
        );
      }

      // Create simplified edges (only for some voxels)
      function createSimplifiedEdges(voxels, shape, centerOffset, brainGroup) {
        // Create a merged geometry for edges
        const edgePositions = [];

        // Create a box geometry for reference
        const boxSize = 0.92;
        const halfSize = boxSize / 2;

        // Define the 12 edges of a cube
        const edgeDefinitions = [
          // Bottom face
          [-halfSize, -halfSize, -halfSize, halfSize, -halfSize, -halfSize],
          [halfSize, -halfSize, -halfSize, halfSize, -halfSize, halfSize],
          [halfSize, -halfSize, halfSize, -halfSize, -halfSize, halfSize],
          [-halfSize, -halfSize, halfSize, -halfSize, -halfSize, -halfSize],

          // Top face
          [-halfSize, halfSize, -halfSize, halfSize, halfSize, -halfSize],
          [halfSize, halfSize, -halfSize, halfSize, halfSize, halfSize],
          [halfSize, halfSize, halfSize, -halfSize, halfSize, halfSize],
          [-halfSize, halfSize, halfSize, -halfSize, halfSize, -halfSize],

          // Connecting edges
          [-halfSize, -halfSize, -halfSize, -halfSize, halfSize, -halfSize],
          [halfSize, -halfSize, -halfSize, halfSize, halfSize, -halfSize],
          [halfSize, -halfSize, halfSize, halfSize, halfSize, halfSize],
          [-halfSize, -halfSize, halfSize, -halfSize, halfSize, halfSize],
        ];

        // Only add edges for voxels at regular intervals (reduces number of edges)
        const edgeInterval = 4; // Only show edges for every 4th voxel

        for (let i = 0; i < voxels.length; i++) {
          // Skip some voxels to reduce edge count
          if (i % edgeInterval !== 0) continue;

          const voxel = voxels[i];
          const [x, y, z] = voxel;
          const posX = x + centerOffset[0];
          const posY = y + centerOffset[1];
          const posZ = z + centerOffset[2];

          // Add each edge
          for (const [x1, y1, z1, x2, y2, z2] of edgeDefinitions) {
            edgePositions.push(
              posX + x1,
              posY + y1,
              posZ + z1,
              posX + x2,
              posY + y2,
              posZ + z2
            );
          }
        }

        // Create the geometry
        const edgeGeometry = new THREE.BufferGeometry();
        edgeGeometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(edgePositions, 3)
        );

        // Create the material - thinner, semi-transparent edges
        const edgeMaterial = new THREE.LineBasicMaterial({
          color: 0x000000,
          linewidth: 1,
          transparent: true,
          opacity: 0.2, // More subtle edges
        });

        // Create the line segments
        brainEdges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
        brainGroup.add(brainEdges);

        console.log("Added simplified edges to selected voxels");
      }

      // Update brain visualization based on split state
      function updateBrainVisualization() {
        // Remove existing meshes
        if (brainInstancedMesh) brainGroup.remove(brainInstancedMesh);
        if (brainEdges) brainGroup.remove(brainEdges);

        // Remove all active area meshes
        for (const areaName in activeAreas) {
          if (activeAreas[areaName].mesh) {
            brainGroup.remove(activeAreas[areaName].mesh);
          }
        }

        // Calculate center offset
        const centerOffset = [
          -brainShape[0] / 2,
          -brainShape[1] / 2,
          -brainShape[2] / 2,
        ];

        // Recreate brain voxels with filtered data
        createBrainVoxels(brainVoxels, brainShape, centerOffset, brainGroup);

        // Recreate all active areas
        for (const areaName in activeAreas) {
          if (activeAreas[areaName].active) {
            addAreaVoxels(
              areaName,
              activeAreas[areaName].voxels,
              activeAreas[areaName].shape,
              areaColors[areaName]
            );
          }
        }

        console.log(`Brain visualization updated. Split mode: ${isBrainSplit}`);
      }

      // New function to load available areas
      function loadAvailableAreas() {
        // Fetch the list of available area JSON files
        fetch("areas_index.json")
          .then((response) => {
            if (!response.ok) {
              throw new Error("Could not load areas index");
            }
            return response.json();
          })
          .then((data) => {
            availableAreas = data.areas;

            // Initialize area colors
            availableAreas.forEach((area, index) => {
              // Assign a color from the palette, cycling if needed
              areaColors[area.name] = colorPalette[index % colorPalette.length];
            });

            // Populate the area list
            updateAreaList();
          })
          .catch((error) => {
            console.error("Error loading areas index:", error);

            // If areas_index.json doesn't exist, create a fallback with known areas
            console.log("Using fallback area list");
            availableAreas = [
              {
                name: "dlpfc",
                file: "dlpfc_atlas_voxels.json",
                description: "Dorsolateral Prefrontal Cortex",
              },
              {
                name: "broca",
                file: "broca_atlas_voxels.json",
                description: "Broca's Area",
              },
            ];

            // Initialize area colors for fallback
            availableAreas.forEach((area, index) => {
              areaColors[area.name] = colorPalette[index % colorPalette.length];
            });

            // Populate the area list with fallback data
            updateAreaList();
          });
      }

      // Function to update the area list in the UI
      function updateAreaList(searchTerm = "") {
        const areaList = document.getElementById("area-list");
        areaList.innerHTML = ""; // Clear existing list

        // Filter areas based on search term
        const filteredAreas = searchTerm
          ? availableAreas.filter(
              (area) =>
                area.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                (area.description &&
                  area.description
                    .toLowerCase()
                    .includes(searchTerm.toLowerCase()))
            )
          : availableAreas;

        if (filteredAreas.length === 0) {
          areaList.innerHTML =
            '<div class="no-areas-found">No areas found matching your search</div>';
          return;
        }

        // Create checkbox for each area
        filteredAreas.forEach((area) => {
          const areaItem = document.createElement("div");
          areaItem.className = "area-item";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "area-checkbox";
          checkbox.id = `area-${area.name}`;
          checkbox.checked = activeAreas[area.name]?.active || false;
          checkbox.addEventListener("change", () => toggleArea(area));

          const colorBox = document.createElement("span");
          colorBox.className = "area-color";
          colorBox.style.backgroundColor = `#${areaColors[area.name]
            .toString(16)
            .padStart(6, "0")}`;

          const label = document.createElement("label");
          label.htmlFor = `area-${area.name}`;
          label.textContent = area.description || area.name;

          areaItem.appendChild(checkbox);
          areaItem.appendChild(colorBox);
          areaItem.appendChild(label);
          areaList.appendChild(areaItem);
        });
      }

      // Function to set up area search
      function setupAreaSearch() {
        const searchInput = document.getElementById("area-search");
        searchInput.addEventListener("input", (e) => {
          updateAreaList(e.target.value);
        });
      }

      // Function to toggle an area on/off
      function toggleArea(area) {
        const checkbox = document.getElementById(`area-${area.name}`);
        const isActive = checkbox.checked;

        if (
          isActive &&
          (!activeAreas[area.name] || !activeAreas[area.name].voxels)
        ) {
          // Area is being activated and we don't have the data yet
          loadAreaData(area);
        } else if (activeAreas[area.name]) {
          // We already have the data, just toggle visibility
          activeAreas[area.name].active = isActive;

          if (isActive) {
            // Add the area to visualization
            addAreaVoxels(
              area.name,
              activeAreas[area.name].voxels,
              activeAreas[area.name].shape,
              areaColors[area.name]
            );
          } else {
            // Remove the area from visualization
            if (activeAreas[area.name].mesh) {
              brainGroup.remove(activeAreas[area.name].mesh);
              activeAreas[area.name].mesh = null;
            }
          }

          // Update the legend
          updateLegend();
        }
      }

      // Function to load area data
      function loadAreaData(area) {
        console.log(`Loading data for ${area.name}...`);

        // Show loading indicator
        const loadingDiv = document.getElementById("loading");
        loadingDiv.textContent = `Loading ${area.description || area.name}...`;
        loadingDiv.style.display = "block";

        fetch(area.file)
          .then((response) => {
            if (!response.ok) {
              throw new Error(`Could not load data for ${area.name}`);
            }
            return response.json();
          })
          .then((data) => {
            // Store the area data
            activeAreas[area.name] = {
              active: true,
              voxels: data.voxels,
              shape: data.shape,
              mesh: null,
            };

            // Add the area to visualization
            addAreaVoxels(
              area.name,
              data.voxels,
              data.shape,
              areaColors[area.name]
            );

            // Update the legend
            updateLegend();

            // Hide loading indicator
            loadingDiv.style.display = "none";
          })
          .catch((error) => {
            console.error(`Error loading ${area.name} data:`, error);

            // Uncheck the checkbox
            const checkbox = document.getElementById(`area-${area.name}`);
            checkbox.checked = false;

            // Show error message
            loadingDiv.textContent = `Error loading ${
              area.description || area.name
            }. Check console for details.`;
            setTimeout(() => {
              loadingDiv.style.display = "none";
            }, 3000);
          });
      }

      // Function to add area voxels to the visualization
      function addAreaVoxels(areaName, voxels, shape, color) {
        console.log(`Adding ${voxels.length} voxels for ${areaName}...`);

        // Calculate center offset to match the main brain
        const centerOffset = [-shape[0] / 2, -shape[1] / 2, -shape[2] / 2];

        // Filter voxels based on split brain state
        const filteredVoxels = isBrainSplit
          ? voxels.filter((voxel) => voxel[0] <= shape[0] / 2)
          : voxels;

        // Create a box for each voxel
        const boxSize = 0.92; // Same size as main brain voxels
        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);

        // Create a material for the area voxels
        const material = new THREE.MeshStandardMaterial({
          color: color,
          roughness: 0.6,
          metalness: 0.2,
          transparent: false,
          side: THREE.FrontSide,
          flatShading: true,
          emissive: new THREE.Color(color).multiplyScalar(0.3), // Slight emissive glow
          emissiveIntensity: 0.3,
        });

        // Use instanced mesh for better performance
        const instancedMesh = new THREE.InstancedMesh(
          boxGeometry,
          material,
          filteredVoxels.length
        );

        // Set matrix for each instance
        const matrix = new THREE.Matrix4();
        for (let i = 0; i < filteredVoxels.length; i++) {
          const voxel = filteredVoxels[i];
          const [x, y, z] = voxel;

          matrix.setPosition(
            x + centerOffset[0],
            y + centerOffset[1],
            z + centerOffset[2]
          );

          instancedMesh.setMatrixAt(i, matrix);
        }

        // Update instance matrix
        instancedMesh.instanceMatrix.needsUpdate = true;

        // Add the area voxels to the brain group
        brainGroup.add(instancedMesh);

        // Store reference to the mesh
        activeAreas[areaName].mesh = instancedMesh;

        console.log(`${areaName} voxels added with custom color`);
      }

      // Function to update the legend based on active areas
      function updateLegend() {
        const legend = document.querySelector(".legend");
        legend.innerHTML = `
          <p><strong>Legend:</strong></p>
          <p><span class="color-box" style="background-color:#888888"></span> Whole Brain Surface</p>
        `;

        // Add active areas to legend
        for (const areaName in activeAreas) {
          if (activeAreas[areaName].active) {
            const area = availableAreas.find((a) => a.name === areaName);
            const description = area ? area.description || areaName : areaName;
            const colorHex = `#${areaColors[areaName]
              .toString(16)
              .padStart(6, "0")}`;

            legend.innerHTML += `
              <p><span class="color-box" style="background-color:${colorHex}"></span> ${description}</p>
            `;
          }
        }
      }

      // Initialize and start animation
      init();
      animate();
    </script>
  </body>
</html>
