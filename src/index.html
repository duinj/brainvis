<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Brain Voxel Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: white;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #333;
        font-family: Arial, sans-serif;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
        border-radius: 5px;
        max-width: 300px;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: Arial, sans-serif;
        font-size: 24px;
        color: #333;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 20px;
        border-radius: 10px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h2>3D Brain Voxel Visualization</h2>
      <p>Loading voxels: <span id="voxel-count">0</span></p>
      <p>Brain dimensions: <span id="dimensions">Loading...</span></p>
      <p>
        Controls: Left-click + drag to rotate, scroll to zoom, right-click +
        drag to pan
      </p>
    </div>
    <div id="loading">Loading brain voxels...</div>

    <script>
      // Main Three.js variables
      let scene, camera, renderer, controls;
      let voxelCount = 0;

      // Initialize the scene
      function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Create camera
        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );
        camera.position.set(100, 100, 100);

        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Add orbit controls for interaction
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // Handle window resize
        window.addEventListener("resize", onWindowResize, false);

        // Load and visualize voxels
        loadVoxels();
      }

      // Handle window resize
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }

      // Load voxels from JSON file
      function loadVoxels() {
        fetch("whole_brain_atlas_voxels.json")
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.json();
          })
          .then((data) => {
            const voxels = data.voxels;
            const shape = data.shape;

            // Update info panel
            document.getElementById(
              "dimensions"
            ).textContent = `${shape[0]} × ${shape[1]} × ${shape[2]}`;

            // Create brain volume visualization
            createBrainVolume(voxels, shape);

            // Hide loading message
            document.getElementById("loading").style.display = "none";
          })
          .catch((error) => {
            console.error("Error loading voxel data:", error);
            document.getElementById("loading").textContent =
              "Error loading voxel data. Check console for details.";
          });
      }

      // Create brain volume visualization
      function createBrainVolume(voxels, shape) {
        // Create a group to hold all elements
        const brainGroup = new THREE.Group();

        // Calculate center offset to center the brain
        const centerOffset = [-shape[0] / 2, -shape[1] / 2, -shape[2] / 2];

        // Create coordinate system grid
        const gridHelper = new THREE.GridHelper(
          Math.max(...shape),
          Math.max(...shape)
        );
        gridHelper.position.set(
          centerOffset[0] + shape[0] / 2,
          centerOffset[1],
          centerOffset[2] + shape[2] / 2
        );
        brainGroup.add(gridHelper);

        // Add axes helper
        const axesHelper = new THREE.AxesHelper(Math.max(...shape) * 0.5);
        axesHelper.position.set(
          centerOffset[0],
          centerOffset[1],
          centerOffset[2]
        );
        brainGroup.add(axesHelper);

        // Create wireframe for the entire brain volume
        createBrainWireframe(shape, centerOffset, brainGroup);

        // Create filled voxels for the specific regions
        createFilledVoxels(voxels, shape, centerOffset, brainGroup);

        // Add the brain group to the scene
        scene.add(brainGroup);

        // Adjust camera position based on brain size
        const maxDim = Math.max(...shape) * 1.5;
        camera.position.set(maxDim, maxDim, maxDim);
        controls.update();

        // Update voxel count
        document.getElementById("voxel-count").textContent = voxels.length;
      }

      // Create wireframe for the entire brain volume
      function createBrainWireframe(shape, centerOffset, brainGroup) {
        console.log("Creating brain volume wireframe...");

        // Create wireframe for the entire brain volume
        const wireframeMaterial = new THREE.LineBasicMaterial({
          color: 0xcccccc,
          opacity: 0.2,
          transparent: true,
        });

        // Create a box representing the entire brain volume
        const volumeGeometry = new THREE.BoxGeometry(
          shape[0],
          shape[1],
          shape[2]
        );
        const volumeEdges = new THREE.EdgesGeometry(volumeGeometry);
        const volumeWireframe = new THREE.LineSegments(
          volumeEdges,
          wireframeMaterial
        );

        // Position the wireframe at the center of the volume
        volumeWireframe.position.set(
          centerOffset[0] + shape[0] / 2,
          centerOffset[1] + shape[1] / 2,
          centerOffset[2] + shape[2] / 2
        );

        brainGroup.add(volumeWireframe);

        // Create a grid of lines to show the voxel boundaries (only at intervals to avoid too many lines)
        const interval = Math.max(5, Math.floor(Math.max(...shape) / 20)); // Adjust interval based on brain size

        // Create lines for each axis
        for (let i = 0; i <= shape[0]; i += interval) {
          for (let j = 0; j <= shape[1]; j += interval) {
            // Create Z-axis line
            const zGeometry = new THREE.BufferGeometry();
            zGeometry.setAttribute(
              "position",
              new THREE.Float32BufferAttribute(
                [
                  i + centerOffset[0],
                  j + centerOffset[1],
                  centerOffset[2],
                  i + centerOffset[0],
                  j + centerOffset[1],
                  shape[2] + centerOffset[2],
                ],
                3
              )
            );
            const zLine = new THREE.Line(zGeometry, wireframeMaterial);
            brainGroup.add(zLine);
          }
        }

        for (let i = 0; i <= shape[0]; i += interval) {
          for (let k = 0; k <= shape[2]; k += interval) {
            // Create Y-axis line
            const yGeometry = new THREE.BufferGeometry();
            yGeometry.setAttribute(
              "position",
              new THREE.Float32BufferAttribute(
                [
                  i + centerOffset[0],
                  centerOffset[1],
                  k + centerOffset[2],
                  i + centerOffset[0],
                  shape[1] + centerOffset[1],
                  k + centerOffset[2],
                ],
                3
              )
            );
            const yLine = new THREE.Line(yGeometry, wireframeMaterial);
            brainGroup.add(yLine);
          }
        }

        for (let j = 0; j <= shape[1]; j += interval) {
          for (let k = 0; k <= shape[2]; k += interval) {
            // Create X-axis line
            const xGeometry = new THREE.BufferGeometry();
            xGeometry.setAttribute(
              "position",
              new THREE.Float32BufferAttribute(
                [
                  centerOffset[0],
                  j + centerOffset[1],
                  k + centerOffset[2],
                  shape[0] + centerOffset[0],
                  j + centerOffset[1],
                  k + centerOffset[2],
                ],
                3
              )
            );
            const xLine = new THREE.Line(xGeometry, wireframeMaterial);
            brainGroup.add(xLine);
          }
        }

        console.log("Brain volume wireframe created");
      }

      // Create filled voxels for specific regions
      function createFilledVoxels(voxels, shape, centerOffset, brainGroup) {
        console.log(
          `Creating filled voxels for ${voxels.length} coordinates...`
        );

        // Determine if we need to use different rendering methods based on voxel count
        const totalVoxels = voxels.length;

        if (totalVoxels > 50000) {
          // For very large datasets, use point cloud
          createVoxelPointCloud(voxels, shape, centerOffset, brainGroup);
        } else {
          // For smaller datasets, use instanced mesh
          createVoxelInstancedMesh(voxels, shape, centerOffset, brainGroup);
        }
      }

      // Create a point cloud for voxels (for very large datasets)
      function createVoxelPointCloud(voxels, shape, centerOffset, brainGroup) {
        const positions = new Float32Array(voxels.length * 3);
        const colors = new Float32Array(voxels.length * 3);

        for (let i = 0; i < voxels.length; i++) {
          const voxel = voxels[i];
          const [x, y, z] = voxel;

          // Set position
          positions[i * 3] = x + centerOffset[0];
          positions[i * 3 + 1] = y + centerOffset[1];
          positions[i * 3 + 2] = z + centerOffset[2];

          // Set color (gradient based on height)
          const heightRatio = y / shape[1];
          colors[i * 3] = 0.3 + 0.7 * heightRatio; // R
          colors[i * 3 + 1] = 0.5; // G
          colors[i * 3 + 2] = 0.8 - 0.5 * heightRatio; // B
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
          size: 0.8,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          sizeAttenuation: true,
        });

        const pointCloud = new THREE.Points(geometry, material);
        brainGroup.add(pointCloud);

        console.log("Voxels rendered as point cloud for performance");
      }

      // Create instanced mesh for voxels
      function createVoxelInstancedMesh(
        voxels,
        shape,
        centerOffset,
        brainGroup
      ) {
        // Create a slightly smaller box to avoid z-fighting with the wireframe
        const boxSize = 0.9;
        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
        const material = new THREE.MeshPhongMaterial({
          color: 0x88ccff,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide,
        });

        // Create instanced mesh
        const instancedMesh = new THREE.InstancedMesh(
          boxGeometry,
          material,
          voxels.length
        );

        // Set matrix for each instance
        const matrix = new THREE.Matrix4();
        for (let i = 0; i < voxels.length; i++) {
          const voxel = voxels[i];
          const [x, y, z] = voxel;

          matrix.setPosition(
            x + centerOffset[0],
            y + centerOffset[1],
            z + centerOffset[2]
          );

          instancedMesh.setMatrixAt(i, matrix);

          // Set color based on height
          const heightRatio = y / shape[1];
          const color = new THREE.Color(
            0.3 + 0.7 * heightRatio, // R
            0.5, // G
            0.8 - 0.5 * heightRatio // B
          );
          instancedMesh.setColorAt(i, color);
        }

        // Update instance matrix and colors
        instancedMesh.instanceMatrix.needsUpdate = true;
        if (instancedMesh.instanceColor) {
          instancedMesh.instanceColor.needsUpdate = true;
        }

        brainGroup.add(instancedMesh);
        console.log("Voxels rendered as instanced mesh");
      }

      // Initialize and start animation
      init();
      animate();
    </script>
  </body>
</html>
